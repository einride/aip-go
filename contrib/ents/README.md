# AIP Helpers for Ent

`go.einride.tech/aip/contrib/ents` bridges the [Google AIP](https://google.aip.dev) filtering and ordering helpers from `go.einride.tech/aip` with the lower-level SQL selector used by [ent](https://entgo.io/). It lets you translate validated filter and order expressions into the `func(*sql.Selector)` hooks that ent queries already understand.

## Installation

```bash
go get go.einride.tech/aip/contrib/ents
```

## Quick Start

The helpers expect parsed and type-checked values from the `filtering` and `ordering` packages. Once you have those, pass them to `QueryBy` and `OrderBy` before executing an ent query.

```go
package foo

import (
    "context"

    "github.com/go-kratos/kratos-admin/internal/data/ent" // generated by ent
    "go.einride.tech/aip/contrib/ents"
    "go.einride.tech/aip/filtering"
    "go.einride.tech/aip/ordering"
)

type ListFoosRequest struct {
    Filter  string
    OrderBy string
}

func (r ListFoosRequest) GetFilter() string  { return r.Filter }
func (r ListFoosRequest) GetOrderBy() string { return r.OrderBy }

func ListFoos(ctx context.Context, client *ent.Client, req ListFoosRequest) ([]*ent.Foo, error) {
    declarations, err := filtering.NewDeclarations(
        filtering.DeclareStandardFunctions(),
        filtering.DeclareIdent("name", filtering.TypeString),
        filtering.DeclareIdent("created_at", filtering.TypeTimestamp),
    )
    if err != nil {
        return nil, err
    }

    filter, err := filtering.ParseFilter(req, declarations)
    if err != nil {
        return nil, err
    }

    orderBy, err := ordering.ParseOrderBy(req)
    if err != nil {
        return nil, err
    }

    foos, err := client.Foo.Query()
        .Where(ents.QueryBy(filter))
        .Order(ents.OrderBy(orderBy))
        .All(ctx)

    return foos, err
}
```

In production code you would use your generated protobuf (or HTTP request) type instead of `ListFoosRequest`; the only requirement is that it implements the `filtering.Request` and `ordering.Request` interfaces (`GetFilter()` and `GetOrderBy()`). Make sure your declarations match the fields and functions you allow clients to use.

## Filtering Support

- Logical operators `AND`, `OR`, and `NOT` map to the equivalent SQL predicates.
- Comparison operators (`=`, `!=`, `<`, `<=`, `>`, `>=`) work between columns and literal values or between two columns.
- The `:` operator (`has`) becomes a `LIKE '%value%'` (`sql.Contains`) predicate.
- Literal conversions cover booleans, strings, integers, doubles, durations (`duration("1h")`), and timestamps (`timestamp("2006-01-02T15:04:05Z")`).
- If a filter expression cannot be translated, `QueryBy` safely returns a no-op so the query still executes.

## Ordering Support

- `OrderBy` consumes a parsed `ordering.OrderBy` value (for example from `ordering.ParseOrderBy`).
- Each field path becomes either `sql.Asc` or `sql.Desc` on the selector, preserving dotted paths for nested columns or joins.
- Invalid or empty ordering strings are surfaced while parsing, before the selector is modified.

## Tips

- Centralize your `filtering.Declarations` so the same validation is shared between your API layer and ent integration.
- Combine `QueryBy` with other ent `Modify` calls to append additional predicates or joins as needed.
- When you add new sortable or filterable fields, update the declarations and regenerate any service documentation accordingly.
